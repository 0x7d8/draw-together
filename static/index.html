<!DOCTYPE html>
<html>
<head>
	<title>Draw Together!</title>
	<meta name="darkreader-lock">
	<link rel="icon" type="image/png" href="https://cdn.rjns.dev/profile/pfp.png">
	<script src="https://cdn.tailwindcss.com"></script>
</head>
<body style="background-color: #ffffff" onload="body = document.querySelector('body')">
  <nav class="flex flex-row justify-between bg-gray-800" style="height: 50px">
		<div class="flex flex-row items-center">
			<select id="shape-selector" class="ml-2 bg-gray-500 h-full rounded p-2 hover:bg-gray-400 cursor-pointer">
				<option value="cube-normal">Cube [Normal]</option>
				<option value="cube-hollow">Cube [Hollow]</option>
				<option value="circle-normal">Circle [Normal]</option>
				<option value="circle-hollow">Circle [Hollow]</option>
				<option value="triangle-normal">Triangle [Normal]</option>
				<option value="triangle-hollow">Triangle [Hollow]</option>
				<option value="erase">Erase</option>
			</select>
			<input type="color" id="color-picker" class="ml-2 bg-gray-500 h-full rounded p-2 hover:bg-gray-400 cursor-pointer">
			<input type="range" id="size-slider" value="1" min="1" max="31" class="ml-2 cursor-pointer">
		</div>

		<div class="flex flex-col items-center text-white text-right pr-2">
			<h1>Draw Together!</h1>
			<span id="status">Connecting...</span>
		</div>
  </nav>
	<style>
		#canvas {
			cursor: crosshair;
			width: 100%;
    	height: calc(100vh - 50px);
		}
	</style>
	<canvas hidden id="canvas"></canvas>
	<div id="loading" class="absolute inset-0 flex flex-col items-center justify-center">
		<h1>Loading Data...</h1>
	</div>
</body>

<script>
	let messages = 0, bytes = 0

	setInterval(() => {
		document.getElementById('status').innerText = `Connected: ${messages} Messages | ${bytes} Bytes`
	}, 500)

	fetch('/history_2.raw')
		.then((res) => res.arrayBuffer())
		.then((buf) => new Uint8Array(buf))
		.then((arr) => {
			let offset = 0

			while (offset < arr.length) {
				const [ type, height, color ] = fromFormatInternal(arr.slice(offset, offset + 4))
				const x = (offset / 4) % 1920
				const y = Math.floor((offset / 4) / 1920)

				draw(x, y, color, type, height)

				offset += 4
			}

			document.getElementById('loading').remove()
			document.getElementById('canvas').hidden = false
		})

	const types = [
		'erase',
		'cube-normal',
		'cube-hollow',
		'circle-normal',
		'circle-hollow',
		'triangle-normal',
		'triangle-hollow'
	]

	function toFormat(type, x, y, height, _color) {
		const buffer = new Uint8Array([
			types.indexOf(type) | (height << 3),
			(x & 0xFF),
			((x >> 8) & 0xF) | ((y & 0xF) << 4),
			(y >> 4) & 0xFF,
			parseInt(_color.slice(1, 3), 16),
			parseInt(_color.slice(3, 5), 16),
			parseInt(_color.slice(5, 7), 16)
		])

		return buffer
	}

	function fromFormat(buffer) {
		const type = buffer[0] & 0b111
		const height = buffer[0] >> 3
		const color = `#${buffer[4].toString(16).padStart(2, '0')}${buffer[5].toString(16).padStart(2, '0')}${buffer[6].toString(16).padStart(2, '0')}`

		const x = buffer[1] | ((buffer[2] & 0xF) << 8)
		const y = (buffer[2] >> 4) | (buffer[3] << 4)

		if (!types[type] || color.length < 7 || !height) throw 'Invalid Format'

		return [types[type], x, y, height, color]
	}

	function fromFormatInternal(buffer) {
		const type = buffer[0] & 0b111
		const height = buffer[0] >> 3
		const color = `#${buffer[1].toString(16).padStart(2, '0')}${buffer[2].toString(16).padStart(2, '0')}${buffer[3].toString(16).padStart(2, '0')}`

		return [types[type], height, color]
	}

	const canvas = document.getElementById('canvas')

	if (window.innerWidth > window.innerHeight) {
		canvas.width = 1920
		canvas.height = 1000
	} else {
		canvas.width = 1000
		canvas.height = 1920
	}

	const websocket = new WebSocket(`${window.location.protocol.replace('http', 'ws')}//${window.location.host}/ws`)

	websocket.addEventListener('open', () => {
		document.getElementById('status').innerText = 'Connected | 0 Messages | 0 Bytes'
	})

	websocket.addEventListener('close', () => {
		alert('Connection Closed')

		setTimeout(() => {
			window.location.reload()
		}, 1000)
	})

	websocket.addEventListener('error', () => {
		alert('Connection Error')

		setTimeout(() => {
			window.location.reload()
		}, 1000)
	})

	websocket.addEventListener('message', async(e) => {
		const ab = await e.data.arrayBuffer()
		bytes += ab.byteLength

		for (let i = 0; i < ab.byteLength / 7; i++) {
			const [ type, x, y, height, color ] = fromFormat(new Uint8Array(ab.slice(i * 7, (i + 1) * 7)))
			draw(x, y, color, type, height)

			messages++
		}
	})

	let action = 'cube-normal'
	let height = 1
	let color = '#000000'

	document.getElementById('shape-selector').addEventListener('input', (e) => {
		action = e.target.value
	})

	document.getElementById('size-slider').addEventListener('input', (e) => {
		height = parseInt(e.target.value)
	})

	document.getElementById('color-picker').addEventListener('input', (e) => {
		color = e.target.value
	})

	function draw(x, y, _color, type, height) {
		const ctx = canvas.getContext('2d')

		if (type === 'erase') {
			ctx.clearRect(x, y, height * 4 * 1.5, height * 4 * 1.5)
		} else {
			ctx.fillStyle = _color

			switch (type) {
				case 'cube-normal':
					ctx.fillRect(x, y, height * 4 * 1.5, height * 4 * 1.5)
					break
				case 'cube-hollow':
					ctx.strokeStyle = _color
					ctx.strokeRect(x, y, height * 4 * 1.5, height * 4 * 1.5)
					break
				case 'circle-normal':
					ctx.beginPath()
					ctx.arc(x, y, height * 4, 0, 2 * Math.PI)
					ctx.fill()
					break
				case 'circle-hollow':
					ctx.beginPath()
					ctx.arc(x, y, height * 4, 0, 2 * Math.PI)
					ctx.strokeStyle = _color
					ctx.stroke()
					break
				case 'triangle-normal':
					ctx.beginPath()
					ctx.moveTo(x, y)
					ctx.lineTo(x + height * 4, y + height * 4)
					ctx.lineTo(x - height * 4, y + height * 4)
					ctx.fill()
					break
				case 'triangle-hollow':
					ctx.beginPath()
					ctx.moveTo(x, y)
					ctx.lineTo(x + height * 4, y + height * 4)
					ctx.lineTo(x - height * 4, y + height * 4)
					ctx.closePath()
					ctx.strokeStyle = _color
					ctx.stroke()
					break
			}
		}
	}

	const messageCache = []

	setInterval(() => {
		if (messageCache.length) {
			const messages = Array.from(messageCache)
			messageCache.length = 0

			websocket.send(new Blob(messages))
		}
	}, 50)

	function translateResizedMovement(clientX, clientY) {
		const rect = canvas.getBoundingClientRect()
		const scaleX = canvas.width / rect.width
		const scaleY = canvas.height / rect.height
		
		const x = (clientX - rect.left) * scaleX
		const y = (clientY - rect.top) * scaleY

		return [x, y]
	}

	canvas.addEventListener('mousedown', function(event) {
		const [x, y] = translateResizedMovement(event.clientX, event.clientY)
		messageCache.push(toFormat(action, x, y, height, color))
		draw(x, y, color, action, height)
	})

	canvas.addEventListener('mousemove', function(event) {
		if (event.buttons === 1) {
			const [x, y] = translateResizedMovement(event.clientX, event.clientY)
			messageCache.push(toFormat(action, x, y, height, color))
			draw(x, y, color, action, height)
		}
	})
</script>
</html>